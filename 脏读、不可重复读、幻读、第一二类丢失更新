1.脏读（读到回滚的脏数据，针对未提交数据）
A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作，这时候如果事务B回滚，那么A事务读到的数据是不被承认的
2.不可重复读（边读边改，一个事务范围内两个相同的查询却返回了不同数据）
不可重复读是指A事务读取了B事务已经提交的更改数据。假如A在取款事务的过程中，B往该账户转账100，A两次读取的余额发生不一致。
3.幻读（边读边增删，针对其他提交前后，读取数据条数的对比）
A事务读取B事务提交的新增数据,会引发幻读问题。
4.第一类更新丢失（回滚丢失）
A事务撤销时，把已经提交的B事务的更新数据也撤销了。
5.第二类更新丢失（覆盖丢失/两次更新问题）
A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失。

解决办法：
1.脏读：
Read committed   读取已经提交的
2.不可重复度：
Repeatable Read /行级锁
防止读到更改数据，只需对操作的数据添加行级锁，防止操作中的数据发生变化；
3.幻读：
Serializable/表级锁
防止读到新增数据，往往需要添加表级锁，将整张表锁定，防止新增数据（oracle采用多版本数据的方式实现）。
4.第一类更新丢失

5.第二类更新丢失
