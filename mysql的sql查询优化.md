# 获取有性能问题的sql方法：  
    通过慢查询日志，分析工具mysqldumpslow  
    实时方法获取有性能问题：通过information_schema  
# 查询流程与具体内容：  
  #### 1。客户端发送请求给服务器  
  #### 2。服务器查询缓存，有缓存返回结构：  
  通过一个对大小写敏感的哈希查找实现。只能全值匹配。缓存会检查更新，会加锁。  
  所以在读写频繁的系统使用查询缓存会降低查询效率。  
  #### 3。没缓存，解析SQL、预处理、再由优化器生成执行计划  
  解析SQL：通过关键字对MYSQL语句进行解析，生成解析树。
  预处理：检查解析树是否合法  
  优化器：  
&#160;错误优化的原因：  
&#160;&#160;统计信息可能不准确，  
&#160;&#160;执行计划成本估算不等于实际执行计划成本（优化器不能知道页在内存，磁盘上，哪些页面需要顺序，随机读取）。  
&#160;&#160;mysql优化器认为的最优不是时间  
&#160;&#160;mysql不考虑其他并发查询，存储过程，自定义函数，可能会影响当前查询  
&#160;&#160;mysql也会基于一些固定规则来生成执行计划  
&#160;可以优化的内容：  
&#160;&#160;重新定义表的关联顺序  
&#160;&#160;&#160;&#160;根据统计信息  
&#160;&#160;&#160;&#160;将外连接转化为内链接：外连接等价于内链接情况  
&#160;&#160;&#160;&#160;使用等价变化规则：如 5 =5 and a>5  => a>5  
&#160;&#160;优化count，min，max： 
&#160;&#160;&#160;&#160;查询最小和最大，可以直接读取b树第一和最后一个  
&#160;&#160;将一个表达式转化为常数  
&#160;&#160;使用覆盖索引返回查询信息  
&#160;&#160;子查询优化：转化为关联查询  
&#160;&#160;提前终止查询：limit或一个不成立的条件  
&#160;&#160;对in条件优化（比or块，in中的数据先排序，二分查找来确定是否满足条件）  
  #### 4。Mysql根据执行计划，调用存储引擎的API查询  
  #### 5。返回结果  
  #### 2到5都有可能对查询造成影响  
#  如何确定查询处理各个阶段所消耗时间  
&#160;&#160;set profiling=1；show profiles；show profile for query N；
&#160;&#160;使用performance_schema
# 特定SQL的查询优化：
&#160;&#160;大表的更新和删除：分批处理
&#160;&#160;大表结构修改：
&#160;&#160;&#160;&#160;字段类型，字段宽度修改会锁表。改名可以在线修改，主从修改切换，影子表方法（新表复制旧表数据，并用同步器同步更新，修改后，替换旧表），可以用pt-online-schema-chage
&#160;&#160;优化not in 和 <> 查询：
select customer_id,first_name,last_name,email from customer
where customer_id not in (select customer_id from payment) 

select a.customer_id,a.first_name,a.last_name,a.email from customer a
left join payment b on a.customer_id = b.customer_id 
where b.customer_id is null

&#160;&#160;使用汇总表优化查询
汇总表：提前将要统计的数据进行汇总并记录到表按时间段分开中，定期累积更新  
